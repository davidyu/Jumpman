package{	import Box2D.Collision.*;	import Box2D.Collision.Shapes.*;	import Box2D.Common.Math.*;	import Box2D.Dynamics.*;		import flash.display.*;	import flash.events.*;	import flash.geom.*;	import flash.utils.*;		/*---		@author: Lewen Yu		---*/		public class Prop extends Actor	{		//As with the beginning of all classes, we need to declare some basic variables:		private var _density:Number = 0.0;		private var _friction:Number = 1.0;		private var _restitution:Number = 0.0; //it turns out that at 0.1, the characters "bounce" off the ground and this prevents players from mispredicting when to jump.		private var _mySprite:Sprite;				public function Prop(parent:DisplayObjectContainer, location:Point, arrayOfCoords:Array, texture:BitmapData = null, density:Number = 0.0)		{			_density = density;						var myBody:b2Body = createBodyFromCoords(arrayOfCoords, location);						var mySprite:Sprite = createSpriteFromCoords(arrayOfCoords, location, parent, texture);						_mySprite = mySprite;			super(myBody, mySprite, true);		}				private function createSpriteFromCoords(arrayOfCoords:Array, location:Point, parent:DisplayObjectContainer, texture:BitmapData = null):Sprite		{			var newSprite:Sprite = new Sprite();			newSprite.graphics.lineStyle(2, 0x5D7E62);			for each (var listOfPoints:Array in arrayOfCoords) {				var firstPoint:Point = listOfPoints[0];				newSprite.graphics.moveTo(firstPoint.x, firstPoint.y);								//trace(texture);								if (texture != null) newSprite.graphics.beginBitmapFill(texture);				else newSprite.graphics.beginFill(0xB3C67F);								for each (var newPoint:Point in listOfPoints) {					newSprite.graphics.lineTo(newPoint.x, newPoint.y);				}								newSprite.graphics.lineTo(firstPoint.x, firstPoint.y);			}						newSprite.x = location.x;			newSprite.y = location.y;						parent.addChild(newSprite);						return newSprite;		}				private function createBodyFromCoords(arrayOfCoords:Array, location:Point):b2Body		{			//define shapes			var allShapeDefs:Array = [];						for each (var listOfPoints:Array in arrayOfCoords) {				var newShapeDef:b2PolygonDef = new b2PolygonDef();				newShapeDef.vertexCount = listOfPoints.length;				for (var i:int = 0; i < listOfPoints.length; i++) {					var nextPoint:Point = listOfPoints[i];					b2Vec2(newShapeDef.vertices[i]).Set(nextPoint.x / PhysiVals.RATIO, nextPoint.y / PhysiVals.RATIO); 				}				newShapeDef.density = _density;				newShapeDef.friction = _friction;				newShapeDef.restitution = _restitution;				newShapeDef.userData = this;								allShapeDefs.push(newShapeDef);			}						//define body			var propBodyDef:b2BodyDef = new b2BodyDef();			propBodyDef.position.Set(location.x / PhysiVals.RATIO, location.y / PhysiVals.RATIO);						//create body			var propBody:b2Body = PhysiVals.world.CreateBody(propBodyDef);						//create shapes			for each (var newShapeDefToAdd:b2ShapeDef in allShapeDefs) {				propBody.CreateShape(newShapeDefToAdd);			}						propBody.SetMassFromShapes();						return propBody;		}				override protected function updateOtherThings():void		{					}			}}