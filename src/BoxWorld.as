package{		import Box2D.Collision.*;	import Box2D.Collision.Shapes.*;	import Box2D.Common.Math.*;	import Box2D.Dynamics.*;	import Box2D.Dynamics.Joints.*;		import br.com.stimuli.loading.BulkLoader;	import br.com.stimuli.loading.BulkProgressEvent;	import br.com.stimuli.loading.lazyloaders.LazyXMLLoader;		import com.flashdynamix.motion.extras.Emitter;	import com.flashdynamix.motion.layers.BitmapLayer;	import com.freeactionscript.ParallaxField;	import com.gamingyourway.fps.Debug_fps;	import com.neriksworkshop.lib.ASaudio.Track;		import fl.transitions.Tween;	import fl.transitions.easing.*;		import flash.display.*;	import flash.events.*;	import flash.geom.*;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.system.System;	import flash.text.AntiAliasType;	import flash.text.Font;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.ui.Keyboard;	import flash.utils.Timer;	import flash.utils.getDefinitionByName;	/*----		@author: Lewen Yu		---*/		public class BoxWorld extends Sprite	{				const LEVEL_FILEPATH = "levels/";		const ART_FILEPATH = "art/";		const SFX_FILEPATH = "sfx/";		const MAX_LEVEL = 2;		const _STAGEWIDTH:Number = 800;		const _STAGEHEIGHT:Number = 600;				var _level:int = 1;		var _allActors:Array;		var _actorsToRemove:Array;				var _playerA:PlayerActor;		var _playerB:PlayerActor;				var midpointBetweenPlayers:Midpoint;		var _props:Array;		var _fluidBodies:Array;		var _allCameraTargets:Array;		var _width:Number = 200000;		var _height:Number = 200000;						var _canvas:Sprite = new Sprite;		var _underlay:MovieClip = new MovieClip;		var _overlay:Sprite = new Sprite;		var _overlayText:TextField;		var _announcementFont:Font = new Announcement();		var _timer:Timer = new Timer(5000, 1);				//SPECIAL EFFECTS SHIT		var _movementTrail:Sprite;		var _spriteA:Sprite;		var _spriteB:Sprite;		var _emittor:Emitter;		var _particleLayer:BitmapLayer;		var _parallaxField:ParallaxField;						public function BoxWorld()		{				//set up empty canvas for sprites;			addChild(_underlay);			addChild(_canvas);			addChild(_overlay);						buildMenu();			//			set up physics//			setUpWorldPhysics();//			//			//build game environment elements//			buildLevelOne();			//			add them elevators//			addElevators();//			addFloatingPlatforms();			//			add props - whatever goes//			addProps();			//			add critical elements//			addCriticalElements();			//			add collectibles//			addCollectibles();			//			set up triggers//			setUpTriggers();			//			set up guideposts//			setUpGuidePosts();			//			set up hazards//			setUpHazards();			//			set up characters//			makePlayers();			//			set default camera//			Camera.target = midpointBetweenPlayers;			//			add camera controls :: TEMPORARY SOLUTION//			TODO: get rid of these controls and add auto camera controls//			stage.addEventListener(KeyboardEvent.KEY_DOWN, tempCameraControls);			//			make things move!//			stage.addEventListener(Event.ENTER_FRAME, newFrameListener);			//			set up debug draw//			addDebugDraw();			//			set up overlay//			setUpOverlay();			//			add music//			setupBGM();			//			playSoundEffectIndefinitely();//						//			DEBUG TEST -- try out stupid shit//			debugTest();								}						private function loadLevel(levelID:Number):void		{						Camera.stop();						_allActors = [];			_actorsToRemove = [];			_allCameraTargets = [];			_fluidBodies = [];						//set up physics			setUpWorldPhysics();						//build game environment elements			buildLevelFromXML("level_" + levelID + ".xml", "level_" + levelID + "_props.xml");									//playSoundEffectIndefinitely();		}				private function buildLevelFromXML(levelFile:String, propFile:String):void		{						preloadTexturesAndImgs(levelFile);						//when preload is complete, it will build level			var propLoader:URLLoader = new URLLoader();			propLoader.load(new URLRequest(LEVEL_FILEPATH + propFile));			propLoader.addEventListener(Event.COMPLETE, processAndBuildProps);					}				private function reloadLevel(levelID:Number):void		{						_canvas.removeChild(_canvas.getChildByName("victoryMask"));						_allActors = [];			_actorsToRemove = [];			_allCameraTargets = [];			_fluidBodies = [];						buildLevelFromXML("level_" + levelID + ".xml", "level_" + levelID + "_props.xml");						//playSoundEffectIndefinitely();		}				private var _allAssets:LazyXMLLoader;				private function preloadTexturesAndImgs(levelFile:String):void		{			_allAssets = new LazyXMLLoader(LEVEL_FILEPATH + levelFile,										   "textures");			//add something for individual images			_allAssets.addEventListener("complete",										function(e:Event):void										{ 											preloadComplete(e, levelFile);										});						var preloaderTextField:TextField = setUpPreloader();						_allAssets.addEventListener(BulkLoader.PROGRESS, 										function(e:BulkProgressEvent):void										{											preloadProgress(e, preloaderTextField);										});						_allAssets.start();		}				private function preloadComplete(e:Event, levelFile:String):void		{			//preload complete = ready to build level			var levelLoader:URLLoader = new URLLoader();			levelLoader.load(new URLRequest(LEVEL_FILEPATH + levelFile));			levelLoader.addEventListener(Event.COMPLETE,buildLevel,										 false, 0, true);		}				private function setUpPreloader():TextField		{			var preloaderTextField:TextField = new TextField;			//preloaderTextField.textColor = 0xffffff;						var aFormat:TextFormat = new TextFormat();  						aFormat.color = 0xffffff;			aFormat.size = 16;			aFormat.font = _announcementFont.fontName;						preloaderTextField.setTextFormat(aFormat);			preloaderTextField.antiAliasType = AntiAliasType.ADVANCED;			preloaderTextField.name = "preloaderTextField";			_overlay.addChild(preloaderTextField);						return preloaderTextField;		}				private function preloadProgress(e:BulkProgressEvent, 											 preloaderTextField:TextField):void		{			if (e.weightPercent < 1)			{				preloaderTextField.text = "Loading... " + Math.round(e.weightPercent * 100) + "%";								var aFormat:TextFormat = new TextFormat();  								aFormat.color = 0xffffff;				aFormat.size = 16;				aFormat.font = _announcementFont.fontName;								preloaderTextField.setTextFormat(aFormat);				preloaderTextField.antiAliasType = AntiAliasType.ADVANCED;								preloaderTextField.x = (_STAGEWIDTH - preloaderTextField.width)/2;				preloaderTextField.y = (_STAGEHEIGHT - preloaderTextField.height)/2;			}			else if (e.weightPercent == 1)			{				if (_overlay.getChildByName("preloaderTextField") != null)				{ _overlay.removeChild(_overlay.getChildByName("preloaderTextField"));}			}					}				private function playSoundEffectIndefinitely():void		{			var filename = "sfx/stomp" +Math.ceil(Math.random()*2)+ "_alt.mp3";			var silent:Track = new Track(filename);			silent.volume = 0;						silent.loop = true;						silent.start();		}				private function buildLevel(e:Event):void		{			var level = new XML(e.target.data);			var shape:XML; 				// == denoting collection of vertices			var v:XML; 					// == coordinates of a vertex						var shapeArray = new Array();	//declare temp vars for later 			var vertex:Point;						var structureArray = new Array();			var waterArray = new Array();			var acidArray = new Array();						shapeArray = []; 				//initialize everything			vertex = new Point(0,0);						makePlayers(pointFromData(level.playerA.spawn),						pointFromData(level.playerB.spawn));						var bg:Bitmap = _allAssets.getBitmap(level.@background);			_underlay.addChild(bg);						//build parallax bg			_parallaxField = new ParallaxField();									_parallaxField.createField(_underlay, -100, -100, 1000, 800,										level.parallax.num,										level.parallax.@element,										level.parallax.xMas,										level.parallax.yMax);						Camera.parallaxBG = _parallaxField;						//stage.addEventListener(KeyboardEvent.KEY_DOWN, parallaxKeyDown,			//						false, 0, true);			//stage.addEventListener(KeyboardEvent.KEY_UP, parallaxKeyUp, 			//						false, 0, true);						for each (shape in level.pool.shape)			{				if (shape.@type == "water")				{						shapeArray = [];					waterArray = [];										for each (v in shape.v)					{						vertex = pointFromData(v);						shapeArray.push(vertex);					}										waterArray.push(shapeArray);					//create new pool					var pool:Pool = new Pool(_canvas, new Point(0,0), 											 waterArray,											 Number(shape.@linearDrag));					_allActors.push(pool);					_fluidBodies.push(pool);				} 				else if (shape.@type == "acid")				{					shapeArray = [];					waterArray = [];										for each (v in shape.v)					{						vertex = pointFromData(v);						shapeArray.push(vertex);					}										acidArray.push(shapeArray);					var acid:Acid = new Acid(_canvas, new Point(0,0),											 acidArray);					_allActors.push(acid);					_fluidBodies.push(acid);				}			}						for each (shape in level.structure.shape)			{				shapeArray = [];				for each (v in shape.v)				{					vertex = pointFromData(v);					shapeArray.push(vertex);				}				structureArray.push(shapeArray);			}						var ground = new Prop(_canvas, new Point(0,0), structureArray, 				_allAssets.getBitmapData(level.structure.@texture));						_allActors.push(ground);						stage.addEventListener(KeyboardEvent.KEY_DOWN, tempCameraControls);						//make things move!			stage.addEventListener(Event.ENTER_FRAME, newFrameListener);						//set up debug draw			addDebugDraw();						//set up overlay			setUpOverlay();						//play bgm			setupBGM(level);		}				private function pointFromData(str):Point		{			var coords = str.split(",");						return new Point(coords[0],coords[1]);		}				private function b2Vec2FromData(str):b2Vec2		{			var coords = str.split(",");			return new b2Vec2(coords[0], coords[1]);		}				private function processAndBuildProps(e:Event):void		{			var props = new XML(e.target.data);			var type = -1;			for each (var s:XML in props.spring)			{				if (s.@type == "ground") type = Spring.on_ground;				else if (s.@type == "right") type = Spring.float_right;				else if (s.@type == "left") type = Spring.float_left;				if (type != -1)				{					var spring:Spring = new Spring(_canvas,													type,													s.dimensions.width,													s.dimensions.height,													b2Vec2FromData(s.position));				}			}						for each (var p:XML in props.platform)			{				if (p.@type == "automatic")				{					var fp = new FloatingPlatform(	_canvas,													stage, 												 	p.dimensions.width,													p.dimensions.height, 													pointFromData(p.start), 													pointFromData(p.end), 													Number(p.cooldown));					_allActors.push(fp);				}			}						var door1 = new Door(_canvas, stage, this,								 b2Vec2FromData(props.door.position));					}				//clears the current level to make space for a new one		private function clearLevel():void		{			for each (var actor:Actor in _allActors)//iterate thru actors array			{				//trace(actor);				safeRemoveActor(actor);			}						Camera.stop();				//clear camera references			Camera.clearALlReferences();						_playerA = null;			//clear player references			_playerB = null;						_allAssets.clear();	//clear bulkLoader		}				public function get canvas():Sprite { return _canvas; }		public function get playerA():PlayerActor { return _playerA; }		public function get playerB():PlayerActor { return _playerB; }				private function setupBGM(level:XML):void		{			//var bgm:Track = new Track("Hendrix in China.mp3");			//bgm.start();			//bgm.volume = 0.4;						if (level.@music != "none")			{				var bgm:Sound = _allAssets.getSound(level.@music);				bgm.play();			}		}				//throws your actors in the recycling bin		public function safeRemoveActor(actorToRemove:Actor):void		{			if(_actorsToRemove.indexOf(actorToRemove) < 0)			{				_actorsToRemove.push(actorToRemove);			}		}				//empties recycling bin and destroys all actors		public function reallyRemoveActors():void		{			var actorIndex:int			for each (var removeMe:Actor in _actorsToRemove)			{				removeMe.destroy();								actorIndex = _allActors.indexOf(removeMe);	//remove from main				if(actorIndex > -1)							//list of actors				{					_allActors.splice(actorIndex, 1);				}								actorIndex = _actorsToRemove.indexOf(removeMe);	//also remove				if(actorIndex > -1)						// from actorsToRemove				{					_actorsToRemove.splice(actorIndex, 1);				}			}		}				public function newMessage(message:String):void		{			_overlayText.alpha = 100;			_overlayText.text = message;			var myFormat:TextFormat = new TextFormat();  						myFormat.color = 0xffffff;   			myFormat.size = 20;			myFormat.font = _announcementFont.fontName;						_overlayText.setTextFormat(myFormat);						_timer.addEventListener(TimerEvent.TIMER, fadeMessage);			_timer.start();						_overlayText.antiAliasType = AntiAliasType.ADVANCED;		}				private function fadeMessage(ev:TimerEvent):void		{			var fade:Tween = new Tween(_overlayText, "alpha", Strong.easeOut, 100, 0, 2, true);		}						public function clearMessage():void		{			_overlayText.text = "";		}				private function setUpTriggers():void		{			var trigger1:Trigger = new Trigger(new Point(0,0), [[new Point(8300, 1000), new Point(8500, 1000), new Point(8500, 2900), new Point(8300, 2900)]], dropThemBarrels, this);		}				private function addProps():void		{					}				public function dropThemCrates():void		{			PhysiVals.world.Step(1/30.0, 10);						var crate:Array = [[new Point(0,0), new Point(80,0), new Point(80,80), new Point(0,80)]];						var crate1:InteractiveProp = new InteractiveProp(_canvas, new Point(8650, 1300), crate, 2);			_allActors.push(crate1);						PhysiVals.world.Step(1/30.0, 10);						var crate2:InteractiveProp = new InteractiveProp(_canvas, new Point(8850, 1300), crate, 2);			_allActors.push(crate2);					}				public function dropThemBarrels():void		{						PhysiVals.world.Step(1/30.0, 10);						var barrel:RollingBarrel = new RollingBarrel(_canvas, new Point(8700, 1300));			_allActors.push(barrel);						PhysiVals.world.Step(1/30.0, 10);						var barrel2:RollingBarrel = new RollingBarrel(_canvas, new Point(8900, 1300));			_allActors.push(barrel2);						var dropTimer:Timer = new Timer(500, 1);			dropTimer.addEventListener(TimerEvent.TIMER, dropMoreBarrels);			dropTimer.start();					}				public function dropMoreBarrels(ev:TimerEvent):void		{			PhysiVals.world.Step(1/30.0, 10);						var barrel:RollingBarrel = new RollingBarrel(_canvas, new Point(8600, 1300));			_allActors.push(barrel);						PhysiVals.world.Step(1/30.0, 10);						var barrel2:RollingBarrel = new RollingBarrel(_canvas, new Point(8800, 1300));			_allActors.push(barrel2);					}				private function setUpGuidePosts():void		{			var sign1:Sign = new Sign(_canvas, new Point(450, 2850), Sign.ARROW_RIGHT);			var sign2:Sign = new Sign(_canvas, new Point(1250, 3350), Sign.ARROW_UP);			var sign3:Sign = new Sign(_canvas, new Point(2000, 2550), Sign.ARROW_RIGHT);			var sign4:Sign = new Sign(_canvas, new Point(4050, 2550), Sign.ARROW_UP);						//var warning1:Sign = new Sign(_canvas, new Point(1600, 2700), Sign.WARNING_BARREL_ROLLS);			var danger1:Sign = new Sign(_canvas, new Point(3700, 1700), Sign.DANGER_ACID);			var danger2:Sign = new Sign(_canvas, new Point(2200, 2500), Sign.DANGER_SAWBLADES);		}				private function setUpOverlay():void		{						//1. add text field for in-game narration			var myTextField:TextField = new TextField();  						//Add the new textfield instance to the stage with addchild()  			_overlay.addChild(myTextField);						//Define some properties for the text field  			myTextField.text = "WASD/Arrow keys to move. C and Shift to change the camera focus.";			myTextField.width = 800;  			myTextField.x = 25;  			myTextField.y = 25; 			myTextField.embedFonts = true;						//Here are some great properties to define, first one is to make sure the text is not selectable, then adding a border.  			myTextField.selectable = false;						//This is the section for our text styling, first we create a TextFormat instance naming it myFormat  			var myFormat:TextFormat = new TextFormat();  						myFormat.color = 0xffffff;   			myFormat.size = 20;			myFormat.font = _announcementFont.fontName;									//the following are pretty much   			myTextField.setTextFormat(myFormat);  			_overlayText = myTextField;						//2. add debug FPS counter so we can see performance						var fpsCounter:Debug_fps = new Debug_fps(stage, new Point(750, 20));					}				private function debugTest():void		{//			var oldArray:Array = ["dog", "cat", "mouse"];//			//			var newArray:Array = [];//			//			/*for each (var animal:String in oldArray)//			{//				newArray.push(animal);//			}*/ //-works//			//			//newArray = oldArray.splice(); doesn't work//			//			oldArray = [];//			trace(newArray);		}								public function buildMenu():void		{			var menu:MovieClip = new menutemp();			_overlay.addChild(menu);						menu.x = 0;			menu.y = 0;						//var bgm:Track = new Track("soundtrack/Hungry Buns.mp3");			//bgm.loop = false;			//bgm.start();						menu.btnLvl1.addEventListener(MouseEvent.MOUSE_DOWN, loadLvl1M);			function loadLvl1M(event:MouseEvent):void {				menu.parent.removeChild(menu);				loadLevel(1);								var soundFX:Track = new Track("sfx/click.mp3");				soundFX.loop = false;				soundFX.start();			}						menu.btnLvl2.addEventListener(MouseEvent.MOUSE_DOWN, loadLvl2M);			function loadLvl2M(event:MouseEvent):void			{				menu.parent.removeChild(menu);				loadLevel(2);								var soundFX:Track = new Track("sfx/click.mp3");				soundFX.loop = false;				soundFX.start();			}		}				public function celebrate(zoomSubject:b2Body):void		{			var victoryMask:MovieClip = new VictoryMask();			_canvas.addChild(victoryMask);						victoryMask.name = "victoryMask";						victoryMask.x = PhysiVals.pixels(zoomSubject.GetPosition().x);			victoryMask.y = PhysiVals.pixels(zoomSubject.GetPosition().y);			//			stage.addEventListener(KeyboardEvent.KEY_DOWN, victoryBufferListener, false, 0, true);						Camera.subject = zoomSubject;						clearLevel();					}				private function addDebugDraw():void		{			var dbgDraw:b2DebugDraw = new b2DebugDraw();			var dbgSprite:Sprite = new Sprite();			var m_sprite:Sprite = new Sprite();			_canvas.addChild(m_sprite);			m_sprite.addChild(dbgSprite);			dbgDraw.m_sprite=m_sprite;			dbgDraw.m_drawScale=30;			dbgDraw.m_alpha=0;			dbgDraw.m_fillAlpha=0;			dbgDraw.m_lineThickness=1;			dbgDraw.m_drawFlags=b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit;			PhysiVals.world.SetDebugDraw(dbgDraw);		}				private function setUpHazards():void		{			var saw1:SpinningSaw = new SpinningSaw(_canvas, new Point(2400, 2600));			var saw2:SpinningSaw = new SpinningSaw(_canvas, new Point(2850, 2260));						var saw3:SpinningSaw = new SpinningSaw(_canvas, new Point(7950,2000), 350);						var arrayOfAcid:Array = [//[new Point(500,3200), new Point(1300,3200), new Point(1300,3500), new Point(500,3500)],									 [new Point(3600,2450), new Point(4500,2450), new Point(4500,3000), new Point(3600,3000)]];			var arrayOfAcid2:Array = [[new Point(8500,2000), new Point(9000,2000), new Point(9000,3000), new Point(8500,3000)]];			var acid:Acid = new Acid(_canvas, new Point(0,0), arrayOfAcid);			var acid2:Acid = new Acid(_canvas, new Point(0,0), arrayOfAcid2);						_allActors.push(acid, acid2);			_fluidBodies.push(acid, acid2);		}						private function GetPlayersOutOfWater():void		{			for each(var fluid in _fluidBodies) {				fluid.RemoveBody(_playerA.body);				fluid.RemoveBody(_playerB.body);			} 		}				public function GetPlayerOutOfWater(player:PlayerActor):void		{			for each(var fluid in _fluidBodies) {				fluid.RemoveBody(player.body);			}		}				private function addElevators():void		{			var elevator1 = new Elevator(_canvas, stage, 120, 20, new b2Vec2(3290, 2300), new b2Vec2(0, 500), new b2Vec2(3400,1800)); 			//var elevator2 = new Elevator(_canvas, stage, 120, 20, new b2Vec2(1940, 2900), new b2Vec2(0, 300), new b2Vec2(2050,2600));			//var elevator3 = new Elevator(_canvas, stage, 120, 20, new b2Vec2(3407, 2600), new b2Vec2(0, 2000), new b2Vec2(3517, 600));						_allActors.push(elevator1);			_allActors.push(elevator1.controller);						//_allActors.push(elevator2);			//_allActors.push(elevator2.controller);						//_allActors.push(elevator3);			//_allActors.push(elevator3.controller);		}						public function addActor(newActor:Actor):void		{			_allActors.push(newActor);		}				private function addCollectibles():void		{//			var singleLoneCollectible = new GenericCollectible(new Point(0, 2900), _canvas);//			_allActors.push(singleLoneCollectible);						new lineOf(GenericCollectible, new Point(0, 2700), new Point(2000,2700), new Point(100, 0), _canvas);					}				private function newFrameListener(e:Event):void		{			//step it up yo!			PhysiVals.world.Step(1/30.0, 10);						for each (var actor:Actor in _allActors) {				actor.updateNow();			}						for each (var cameraTarget:CameraTarget in _allCameraTargets) {				cameraTarget.updateNow();			}						updateCamera();			//updateSpecialEffects();						reallyRemoveActors();					}				public function deathSparks(player:PlayerActor):void		{			_emittor.x = _canvas.localToGlobal(new Point(player.costume.x, player.costume.y)).x;			_emittor.y = _canvas.localToGlobal(new Point(player.costume.x, player.costume.y)).y;			_emittor.start();		}				public function stopDeathSparks():void		{			_emittor.stop();		}				private function updateCamera():void		{				Camera.updatePosition();			var newX = PhysiVals.pixels(Camera.position.x);			var newY = PhysiVals.pixels(Camera.position.y);			_canvas.x = -1 * newX + _STAGEWIDTH / 2;			_canvas.y = -1 * newY + _STAGEHEIGHT / 2;						//TODO: monitor the velocities of 2 characters and "auto-focus" on the one that moves most. If both are moving equally, follow the leading character (in the current direction)			//If they are moving in opposite directions, let the camera be the boundary.		}				private function makePlayers(spawnA, spawnB):void		{			var controlA = new Control(87, 65, 83, 68, 67, 70);			var controlB = new Control(38, 37, 40, 39, 16, 191);						_playerA = new PlayerActor(this, _canvas, spawnA, new Point(0, 0), controlA); 			_playerB = new PlayerActor(this, _canvas, spawnB, new Point (0, 0), controlB);						_playerA.partner = _playerB;			_playerB.partner = _playerA;						_allActors.push(_playerA);			_allActors.push(_playerB);						//Maybe next time			//_playerA.addTag(PlayerActor.PLAYER_ONE);			//_playerB.addTag(PlayerActor.PLAYER_TWO);						Camera.start();						midpointBetweenPlayers = new Midpoint(_playerA.body, _playerB.body);			_allCameraTargets.push(midpointBetweenPlayers);						Camera.subject = _playerA.body;			Camera.target = midpointBetweenPlayers;					}				public function updateMidpointBetweenPlayers()		{			midpointBetweenPlayers.refresh(_playerA.body, _playerB.body);		}				private function setUpWorldPhysics():void		{			var worldBounds:b2AABB = new b2AABB();						worldBounds.lowerBound.Set(PhysiVals.meters(-_width/2),									   PhysiVals.meters(-_height/2));			worldBounds.upperBound.Set(PhysiVals.meters(_width/2),									   PhysiVals.meters(_height/2));			var allowSleep:Boolean = true;			PhysiVals.world = new b2World(worldBounds, PhysiVals.gravity,										  allowSleep);			PhysiVals.world.SetContactListener(new BoxWorldContactListener(this));		}				//listens for "any key" press and loads next level		private function victoryBufferListener(ev:KeyboardEvent):void		{			if(ev.keyCode)			{				_level++;				reloadLevel(_level);								stage.removeEventListener(KeyboardEvent.KEY_DOWN, victoryBufferListener);				//unloadVictoryScreen();			}		}				public function tempCameraControls(ev:KeyboardEvent):void		{			if(ev.keyCode == 32) {								if(!Camera.trackingTarget)				{					Camera.target = midpointBetweenPlayers;				}				else if(Camera.subject == _playerA.body && Camera.trackingTarget)				{					Camera.subject = _playerB.body;				}				else if(Camera.subject == _playerB.body && Camera.trackingTarget)				{					Camera.subject = _playerA.body;				}								clearMessage();			}						if(ev.keyCode==72) {								var message:String;								message = "(" + 						Math.round(PhysiVals.pixels(_playerA.GetPosition().x))						+ ", " + 						Math.round(PhysiVals.pixels(_playerA.GetPosition().y))						+ "), (" + 						Math.round(PhysiVals.pixels(_playerB.GetPosition().x))						+ ", " + 						Math.round(PhysiVals.pixels(_playerB.GetPosition().y))						+ ")";								newMessage(message);			}						//memcheck code courtesy of PixelBreaker			if(ev.keyCode == 55)			{				var mem:String = Number(System.totalMemory / 1024 / 1024).toFixed( 2 ) + "Mb";				trace("PixelBreaker Memcheck | Currently using" + mem + " of memory.");			}		}				private function parallaxKeyDown(event:KeyboardEvent):void		{			switch( event.keyCode )			{				case Keyboard.UP:					_parallaxField.upPressed = true;									case Keyboard.DOWN:					_parallaxField.downPressed = true;					break;								case Keyboard.LEFT:					_parallaxField.leftPressed = true;					break;								case Keyboard.RIGHT:					_parallaxField.rightPressed = true;					break;			}						event.updateAfterEvent();		}				private function parallaxKeyUp(event:KeyboardEvent):void		{			switch( event.keyCode )			{				case Keyboard.UP:					_parallaxField.upPressed = false;									case Keyboard.DOWN:					_parallaxField.downPressed = false;					break;								case Keyboard.LEFT:					_parallaxField.leftPressed = false;					break;								case Keyboard.RIGHT:					_parallaxField.rightPressed = false;					break;			}		}	}}