/*---@author: Lewen Yu---*///TODO: refine classespackage{	import Box2D.Collision.*;	import Box2D.Collision.Shapes.*;	import Box2D.Common.Math.*;	import Box2D.Dynamics.*;		import com.electrotank.water.Water;	import com.flashdynamix.motion.Tweensy;	import com.flashdynamix.motion.effects.core.ColorEffect;	import com.flashdynamix.motion.effects.core.FilterEffect;	import com.flashdynamix.motion.layers.BitmapLayer;	import com.neriksworkshop.lib.ASaudio.Track;		import flash.display.*;	import flash.events.*;	import flash.filters.BlurFilter;	import flash.geom.*;	import flash.ui.*;	import flash.utils.Timer;		public class PlayerActor extends Actor	{				private static const DEATH_BY_FALLING:int = 2;		private static const DEATH_BY_SAW:int = 3;		private static const DEATH_BY_ACID:int = 4;				private static const HEIGHT:int = 60;		private static const CROUCH_HEIGHT:int = 40;		private static const WIDTH:int = 40;		private static const SENSOR_HEIGHT:int = 10;		private static const BASE_VX = 10;				private static const MAX_ASCENT_SPEED = -25;		private static const MAX_SPRINGJUMP_SPEED = -40;		private static const EXTRA_GRAVITY = 15;				public var INHERIT_VX = 0;		private static const STOMP_SPEED = 40;		//private static const AIR_FRICTION = 0.3;		//private static const DAMPEN = 0.3;				//PLAYER STATES		private var _crouching:Boolean = false;		private var _movingDir:int = 0; //not moving yet		private var _direction:int = 1; //facing the right		private var _bonusVX:Number = 0; //in pixels		private var _shouldJump:Boolean = false;		private var _newX:Number = 0; //already converted to meters		private var _jumpImpulse:b2Vec2 = new b2Vec2(0, 500);		private var _vaultImpulse:b2Vec2 = new b2Vec2(0, -30);		private var _vaultReactionImpulse:b2Vec2 = new b2Vec2(0, 0);		private var _beLeaping:Boolean = false;		public var _inAir:Boolean = false; //public so contact listeners can modify it		private var _hasThePower:Boolean = false;		private var _nearestSwitch:Switch = null;		private var _world:BoxWorld;		private var _dead:Boolean = false;		private var _bouncedOffASpring:Boolean = false;		private var _inWater:Boolean = false;				//CRUCIAL PLAYER BODY VARIABLES		//I keep track of player body shapes for death;		//I want to set the userData to null when they die		private var _playerBodyShape:b2Shape;		private var _playerSpringShape:b2Shape;				//		private var _ridingMovingObject:Boolean = false;		private var _nearHazard:Boolean = false;		private var _onGround:Boolean = false;				//PLAYER DATA		private var _playerControlConfig:Control;		private var _playerController:Controller;				//PLAYER REFERENCES		private var _partner:PlayerActor;				//RESPAWN-POINT-SAVING MECHANISM		private var _potentialRespawnPoints:Array = new Array();		private static const PRP_COUNT:int = 3;		private static const DISTANCE_THRESHOLD:int = 10; //in pixels, only x is taken into consideration		private static const PRP_INTERVAL:int = 100; //in milliseconds		private var _respawnPointSavingTimer:Timer;				//MAGNET MECHANISM		private var _magnetizing:Boolean = false;		private var _partnerPreviousPosition:b2Vec2;				//CHECKPOINTS		private var _latestCheckpointID:int = 0;		private var _latestCheckpointPosition:b2Vec2 = new b2Vec2(0,0);				//SPECIAL EFFECTS		private var _SFX:SpecialEffectsContainer;				//TAGS		public static var PLAYER_ONE:Sprite = new P1TagSprite();		public static var PLAYER_TWO:Sprite = new P2TagSprite();				//TEMP SFX - todo: make a new class TODO		private var _footStep:Track = new Track("sfx/hard footstep.mp3");						//JUMP BOOST		private var _isBoostable:Boolean = false;		private var _jumpBoostTimer:Timer;		private var _boostForce:b2Vec2 = new b2Vec2(0,100);			private function addCheckpoint(ID:int):void		{			if (_latestCheckpointID < ID) {				_latestCheckpointID = ID;				_latestCheckpointPosition = _body.GetPosition();			}		}				private function getLatestCheckpointPosition():b2Vec2		{			return _latestCheckpointPosition;		}						public function PlayerActor(world:BoxWorld, canvas:DisplayObjectContainer, location:Point, velocity:Point, control_config:Control) //init vals		{				//set sound properties			_footStep.loop = true;			_footStep.volume = 2;			_footStep.pause();						//create costume				var playerSprite:Sprite = new CharacterSprite();			playerSprite.scaleX = WIDTH / playerSprite.width;			playerSprite.scaleY = HEIGHT / playerSprite.height;			canvas.addChild(playerSprite);						//define shape			var playerShapeDef:b2PolygonDef = new b2PolygonDef();			playerShapeDef.SetAsBox(PhysiVals.meters(WIDTH / 2), PhysiVals.meters(HEIGHT / 2));			playerShapeDef.friction = 0.0;			playerShapeDef.restitution = 0.0;			playerShapeDef.density = 10;			playerShapeDef.filter.categoryBits = 0x0002; //this sets the player's category			playerShapeDef.userData = this;			//playerShapeDef.filter.maskBits = ~0x0002; //this determines what the player doesn't collide with. Anything under this value.						//define body (paying regards to location)			var playerBodyDef:b2BodyDef = new b2BodyDef();			playerBodyDef.position.Set(PhysiVals.meters(location.x), PhysiVals.meters(location.y));			playerBodyDef.fixedRotation = true;			playerBodyDef.linearDamping = 0.0;						//create body			var playerBody:b2Body = PhysiVals.world.CreateBody(playerBodyDef);						//define ground-sensor			var sensorPosition:b2Vec2 = new b2Vec2(0, PhysiVals.meters(HEIGHT / 2 + SENSOR_HEIGHT / 2));			var groundSensor:b2PolygonDef = new b2PolygonDef();			groundSensor.SetAsOrientedBox(PhysiVals.meters(WIDTH / 2), PhysiVals.meters(SENSOR_HEIGHT / 2), sensorPosition, 0);			groundSensor.isSensor = true;			groundSensor.userData = this;						//define spring			var springPosition:b2Vec2 = new b2Vec2(0, 0 - PhysiVals.meters(HEIGHT / 2));			var springShape: b2PolygonDef = new b2PolygonDef();			springShape.SetAsOrientedBox(PhysiVals.meters(WIDTH / 2), PhysiVals.meters(10), springPosition, 0);			springShape.userData = new VirtualSpring(playerBody, this);			springShape.friction = 0.6;			springShape.restitution = 0.0;			springShape.density = 0.2;			springShape.filter.categoryBits = 0x0004;						//TO DO: something mysterious						//create shape and attach ground sensor			_playerBodyShape = playerBody.CreateShape(playerShapeDef);			//playerBody.CreateShape(groundSensor);			_playerSpringShape = playerBody.CreateShape(springShape);			playerBody.SetMassFromShapes();						//set velocity to match velocity params			var velocityVector:b2Vec2 = new b2Vec2(PhysiVals.meters(velocity.x), PhysiVals.meters(velocity.y));			playerBody.SetLinearVelocity(velocityVector);						//assign player controller			_playerController = new Controller(canvas.stage, this, control_config);			_world = world;						//set up the intelligent respawn point checking mechanism			setUpRespawnPointSavingMechanism();						//put our character in the real world!			super(playerBody, playerSprite, false);						//create SFX layers			_SFX = new SpecialEffectsContainer(playerSprite, canvas);					}				public function recreateBody(canvas:DisplayObjectContainer, location:Point, velocity:Point):void {			//create costume				var playerSprite:Sprite = new CharacterSprite();			playerSprite.scaleX = WIDTH / playerSprite.width;			if (_crouching) {				playerSprite.scaleY = CROUCH_HEIGHT / playerSprite.height;			} else {				playerSprite.scaleY = HEIGHT /playerSprite.height;			}						canvas.addChild(playerSprite);						//define shape			var playerShapeDef:b2PolygonDef = new b2PolygonDef();			if (_crouching) {				playerShapeDef.SetAsBox(PhysiVals.meters(WIDTH / 2), PhysiVals.meters(CROUCH_HEIGHT / 2));			} else {				playerShapeDef.SetAsBox(PhysiVals.meters(WIDTH / 2), PhysiVals.meters(HEIGHT / 2));			}			playerShapeDef.friction = 0.0;			playerShapeDef.restitution = 0.0;			playerShapeDef.density = 4;			playerShapeDef.filter.categoryBits = 0x0002; //this sets the player's category			playerShapeDef.userData = this;			//playerShapeDef.filter.maskBits = ~0x0002; //this determines what the player doesn't collide with. Anything under this value.						//define body (paying regards to location)			var playerBodyDef:b2BodyDef = new b2BodyDef();			playerBodyDef.position.Set(PhysiVals.meters(location.x), PhysiVals.meters(location.y));			playerBodyDef.fixedRotation = true;			playerBodyDef.linearDamping = 0.0;						//create body			var playerBody:b2Body = PhysiVals.world.CreateBody(playerBodyDef);						//define ground-sensor			var sensorPosition:b2Vec2 = new b2Vec2(0, PhysiVals.meters(HEIGHT / 2 + SENSOR_HEIGHT / 2));			var groundSensor:b2PolygonDef = new b2PolygonDef();			groundSensor.SetAsOrientedBox(PhysiVals.meters(WIDTH / 2), PhysiVals.meters(SENSOR_HEIGHT / 2), sensorPosition, 0);			groundSensor.isSensor = true;			groundSensor.userData = this;								//define spring			var springPosition:b2Vec2 = new b2Vec2(0, 0 - PhysiVals.meters(HEIGHT / 2));			var springShape: b2PolygonDef = new b2PolygonDef();			springShape.SetAsOrientedBox(PhysiVals.meters(WIDTH / 2), PhysiVals.meters(10), springPosition, 0);			springShape.userData = new VirtualSpring(playerBody, this);			springShape.friction = 0.6;			springShape.restitution = 0.0;			springShape.density = 0.2;			springShape.filter.categoryBits = 0x0004;						//create shape and update shape reference			_playerBodyShape = playerBody.CreateShape(playerShapeDef);			//playerBody.CreateShape(groundSensor);			_playerSpringShape = playerBody.CreateShape(springShape);			playerBody.SetMassFromShapes();						//set velocity to match velocity params. NOTE that here I leave it in its original meters glory. 			var velocityVector:b2Vec2 = new b2Vec2(velocity.x, velocity.y);			playerBody.SetLinearVelocity(velocityVector);						//put our character in the real world!			refresh(playerBody, playerSprite, false);						_SFX.updatePlayerSpriteReference(playerSprite);								}					public function toggleCrouch(crouching:Boolean):void {						if(!_inWater) {								if (crouching) {					_crouching = true;				} else {					_crouching = false;				}								//save important variables				var canvas = _costume.parent;				var location:Point = new Point(_costume.x, _costume.y + (HEIGHT - CROUCH_HEIGHT)/2);				var velocity:Point = new Point(body.GetLinearVelocity().x, body.GetLinearVelocity().y);				var focusWasOnMe:Boolean = (Camera.subject == _body);								//destroy body				destroy();								//recreate body				recreateBody(canvas, location, velocity);								//reset camera links and references								if(focusWasOnMe) {					Camera.subject = _body;				}								_world.updateMidpointBetweenPlayers();						}					}					public function addTag(tagSprite:Sprite):void		{			_costume.addChild(tagSprite);			tagSprite.y -= 40;		}					public function die():void		{			if(!_dead) {				//do dying animation				_SFX.sparksOfDeath();				//costume.visible = false;								Camera.subject = _body;								var sparkTimer:Timer = new Timer(50, 1);				sparkTimer.addEventListener(TimerEvent.TIMER, stopDeathSparks);				sparkTimer.start();							//focus camera on the other player				//move the body into a safe spot (above the player)												var dummyPlayer = new DummyPlayer(_body, _costume, _playerBodyShape, _playerSpringShape);				_world.addActor(dummyPlayer);								var respawnTimer:Timer = new Timer(2000, 1);				respawnTimer.addEventListener(TimerEvent.TIMER, respawn);				respawnTimer.start();								_dead = true;			}					}					private function stopDeathSparks(ev:TimerEvent):void		{			_SFX.clearSparksOfDeath();		}				public function spawn():void		{			//move the body to its spawn spot (above the player)		}				public function respawn(ev:TimerEvent):void		{			var bestRespawnPoint:Point = new Point(getBestRespawnPoint().x, getBestRespawnPoint().y);			_world.GetPlayerOutOfWater(this);			//get rid of reference				//recreate body			recreateBody(_costume.parent, bestRespawnPoint, new Point(0,0));						//reset camera links and references						_world.updateMidpointBetweenPlayers();						var tempTimer:Timer = new Timer(50, 1);			tempTimer.addEventListener(TimerEvent.TIMER, makeCostumeVisible);			tempTimer.start();												_inWater = false;			_dead = false;		}				private function makeCostumeVisible(ev:TimerEvent) {						_SFX.beautifulShinySpawningMagicEffect();			Camera.subject = _body;			costume.visible = true;						var tempTimer:Timer = new Timer(500, 1);			tempTimer.addEventListener(TimerEvent.TIMER, clearBeautifulShinySpawningMagicEffect);			tempTimer.start();		}				private function clearBeautifulShinySpawningMagicEffect(ev:TimerEvent) {			_SFX.clearBeautifulShinySpawningMagicEffect();		}				public function respawnAtLatestCheckPoint():void		{			_body.SetXForm(getLatestCheckpointPosition(), 0);		}				//public function get body():b2Body { return _body; }				public function get shouldJump():Boolean { return _shouldJump; }				public function get beLeaping():Boolean { return _beLeaping; }				public function set beLeaping(value:Boolean):void { _beLeaping = value; }				public function get WIDTH():int { return 40; }				public function get costume():DisplayObject { return _costume; }				public function get hasThePower():Boolean { return _hasThePower; }				public function get partner():PlayerActor { return _partner; }				public function get world():BoxWorld { return _world; }				public function get playerController():Controller { return _playerController; }				public function get nearHazard():Boolean { return _nearHazard; }				public function get onGround():Boolean { return _onGround; }				public function set shouldJump(value:Boolean):void { _shouldJump = value; }				public function set newX(value:Number):void { _newX = value; }				public function set nearestSwitch(value:Switch):void { _nearestSwitch = value; }				public function set hasThePower(value:Boolean):void { _hasThePower = value; }				public function set ridingMovingObject(value:Boolean):void { _ridingMovingObject = value; }				public function set partner(value:PlayerActor):void { _partner = value; }				public function set nearHazard(value:Boolean):void { _nearHazard = value; }				public function set onGround(value:Boolean):void { _onGround = value; }				public function get bouncedOffASpring():Boolean { return _bouncedOffASpring; }				public function set bouncedOffASpring(value:Boolean):void { _bouncedOffASpring = value; }				public function get isBoostable():Boolean { return _isBoostable; }				public function get isDescending():Boolean { return (_body.GetLinearVelocity().y > 0); }				public function get inWater():Boolean { return _inWater; }				public function set inWater(value:Boolean):void { _inWater = value; }				//JUMP BOOST STUFF		//we have a boolean that dictates when you can apply the jump boost		//a timer that switches off the boolean after some time		//this effectively simulates the "hold down up key to jump higher" behavior present in many		//platformers				public function slowDownAscentIfApplicable():void		{			if(_body.GetLinearVelocity().y < MAX_ASCENT_SPEED * 0.6)			{				_body.SetLinearVelocity(new b2Vec2(_body.GetLinearVelocity().x, MAX_ASCENT_SPEED * 0.6));			}		}				/* TO DO GET RID OF EVERYTHING RELATED TO THIS 		private function turnOnJumpBoostTimer()		{			_isBoostable = true;			_jumpBoostTimer = new Timer(500, 1);			_jumpBoostTimer.addEventListener(TimerEvent.TIMER, finishJumpBoostTimer);			_jumpBoostTimer.start();		}*/				private function finishJumpBoostTimer(ev:TimerEvent)		{			_isBoostable = false;		}								//RESPAWN POINT STUFF				private function setUpRespawnPointSavingMechanism():void		{			_respawnPointSavingTimer = new Timer(PRP_INTERVAL, 0);			_respawnPointSavingTimer.addEventListener(TimerEvent.TIMER, evaluateRespawnPointEvent);			//_potentialRespawnPoints = new Array(PRP_COUNT);		}				private function getBestRespawnPoint():Point		{			var idealPoint = new Point(PhysiVals.pixels(_partner.GetPosition().x), PhysiVals.pixels(_partner.GetPosition().y));			var bestDistance:Number = 9999;			var bestRespawnPoint:Point = new Point(0,0);						for (var i=0; i<_potentialRespawnPoints.length; i++)			{				if(Point.distance(idealPoint,_potentialRespawnPoints[i]) < bestDistance && Point.distance(idealPoint, _potentialRespawnPoints[i]) > 30)				{					bestDistance = Point.distance(idealPoint,_potentialRespawnPoints[i]);					bestRespawnPoint = _potentialRespawnPoints[i];				}			}						return bestRespawnPoint;		}				private function evaluateRespawnPointEvent(ev:TimerEvent):void //an ugly solution to an otherwise simple problem		{			evaluatePotentialRespawnPoint();		}				private function evaluatePotentialRespawnPoint():void		{			var currentPosition:Point = new Point(PhysiVals.pixels(_body.GetPosition().x), PhysiVals.pixels(_body.GetPosition().y));						var nullPoint = new Point(0,0);						var averageRespawnPoint:Point = getAverageRespawnPoint();			if(averageRespawnPoint.equals(nullPoint)) {				addRespawnPoint(currentPosition);				//trace(_potentialRespawnPoints);			} else {				if (Point.distance(averageRespawnPoint, currentPosition) > DISTANCE_THRESHOLD) {					addRespawnPoint(currentPosition);				}			}		}				private function getAverageRespawnPoint():Point		{			if (_potentialRespawnPoints.length > 0)			{				var sum:Point = new Point(0,0);				var n:int = _potentialRespawnPoints.length;				for(var i=0; i<_potentialRespawnPoints.length; i++)				{					sum = sum.add(_potentialRespawnPoints[i]);				}				var averageRespawnPoint:Point = new Point(sum.x/n, sum.y/n);				return averageRespawnPoint;			} else {				return (new Point(0,0));			}		}				private function addRespawnPoint(respawnPoint:Point)		{			if(_potentialRespawnPoints.length>=PRP_COUNT) {				_potentialRespawnPoints.splice(0,0);				_potentialRespawnPoints.push(respawnPoint);			} else {				_potentialRespawnPoints.push(respawnPoint);			}		}				//SOME BASIC MOVEMENT AND JUMPING MECHANICS				public function moveRight():void 		{			_direction = 1;			_movingDir = 1;		}				public function moveLeft():void		{			_direction = -1;			_movingDir = -1;		}				public function stopMoving():void		{			_movingDir = 0;		}				public function jump():void		{			if(!_inAir) {				playJumpSFX();				_inAir = true;				_body.SetLinearVelocity(new b2Vec2(_body.GetLinearVelocity().x, MAX_ASCENT_SPEED));			}					}				public function vaultFromSpring():void		{			if(!_inAir)			{				playSFX("swoosh.mp3");				_inAir = true;				_body.SetLinearVelocity(new b2Vec2(_body.GetLinearVelocity().x, MAX_SPRINGJUMP_SPEED));			}		}				public function stomp():void		{			if(_inAir)			{				_body.SetLinearVelocity(new b2Vec2(0, STOMP_SPEED));				playStompSFX();			}		}					private function playJumpSFX():void		{						var filename = "sfx/jump" + Math.ceil(Math.random()*7) + "_alt.mp3";				var grunt:Track = new Track(filename);			grunt.loop = false;			var swish:Track = new Track("sfx/short swish.mp3");			swish.loop = false;						grunt.start();			swish.start();					}				private function playStompSFX():void		{			var filename = "sfx/stomp" + Math.ceil(Math.random()*2) + "_alt.mp3";			var vocalExclamation:Track = new Track(filename);						vocalExclamation.loop = false;						vocalExclamation.start();					}				private function playVaultingSFX():void		{			var filename = "sfx/vault_scream" + Math.ceil(Math.random()*2) + ".mp3";			var scream:Track = new Track(filename);						scream.loop = false;			scream.start();		}				private function getHeightFromVy(v_y:Number):Number		{			//we'll assume energy is conserved. Kinetic Energy = Gravitational Potential Energy			//therefore, h = v^2 / 2g			//v_y should be in meters						return (Math.pow(v_y, 2) / (2 * PhysiVals.gravity.y));					}				private function getResultantHeightFromInitialHeight(h_initial:Number):Number		{			//we'll use a square root function, because we want the resultant height to decrease the higher the initial height is			//we'll use the multiplier to do modify the height as we see fit.						var MULTIPLIER = 2; //in meters						return (Math.sqrt(MULTIPLIER * h_initial)) + h_initial;					}				private function getResultantVelocityFromResultantHeight(h_resultant:Number):Number		{			//we'll use kinematics here. v_f^2 = v_i^2 + 2ad			//where h_resultant and gravity are SI units						//trace("so resultant velocity is " + PhysiVals.pixels(-Math.sqrt(2 * PhysiVals.gravity.y * h_resultant)));			return -(Math.sqrt(2 * PhysiVals.gravity.y * h_resultant));					}				public function vault(resultantX):void		{						if(!_inAir) {				//Because we know that vault will essentially be called twice (for whatever reason), we're gonna detect the sign of the y component				//of the current velocity. If it's positive, we'll take it into account. Else, don't worry about it								//the following functions describe a method that uses conservation of energy				//Let there be a function f(v) that determins your previous height, given your current y velocity				//Let there be a function g(h) that determines how high you should reach, given y, your previous height.				//Let there be a function h(h) that determines the resultant velocity of the player.												if(_bouncedOffASpring) {					if(_body.GetLinearVelocity().y > 0) {												//this is now completely elastic IE: it doesn't go up any higher than it's supposed to						_body.SetLinearVelocity(new b2Vec2(resultantX, - (_body.GetLinearVelocity().y)));						_inAir = true;					}									} else {										var h_resultant:Number = getResultantHeightFromInitialHeight(getHeightFromVy(_body.GetLinearVelocity().y));					var v_y:Number = getResultantVelocityFromResultantHeight(h_resultant);										_body.SetLinearVelocity(new b2Vec2(resultantX, v_y));									}								if(Math.abs(resultantX) > 1) {					_beLeaping = true;					_SFX.enableMovementTrail(resultantX);					playVaultingSFX();				}							}		}				public function GetPosition():b2Vec2		{			return _body.GetPosition();		}				private function moveX(directionToMove:Number):void		{			var force:b2Vec2 = new b2Vec2((BASE_VX * directionToMove - _body.GetLinearVelocity().x)  * 9 * _body.GetMass(), 0); //on ground			var weakForce:b2Vec2 = new b2Vec2((BASE_VX * directionToMove - _body.GetLinearVelocity().x)  * 5 * _body.GetMass(), 0); //in air						if(!_beLeaping) {				_body.ApplyForce(force, _body.GetPosition());			} else { // apply a weaker force when in air; the player can still reach max speed (BASE_VX), but the acceleration is slower				if((directionToMove > 0 && _body.GetLinearVelocity().x < 0) || (directionToMove < 0 && _body.GetLinearVelocity().x > 0)) { //player is attempting to go back 					_beLeaping = false;				} else if (directionToMove != 0 && _body.GetLinearVelocity().x == 0) {					_beLeaping = false;				}								_SFX.disableMovementTrail();							}						//_body.SetLinearVelocity(new b2Vec2(5*directionToMove, _body.m_linearVelocity.y));									if(!_inAir && !_beLeaping && !_ridingMovingObject && !_nearHazard && onGround) { //you could clean this up				if(directionToMove==0) {					if(_respawnPointSavingTimer.running) { 						_respawnPointSavingTimer.stop();						evaluatePotentialRespawnPoint();					}				} else {					if(!_respawnPointSavingTimer.running) {						_respawnPointSavingTimer.reset();						_respawnPointSavingTimer.start();					}				}			} else {				if(_respawnPointSavingTimer.running) { 					_respawnPointSavingTimer.stop();				}			}					}				public function DisableMovementTrail():void {			_SFX.disableMovementTrail();		}				//INTERACTIVE STUFF				public function activateNearestSwitchIfApplicable():void		{			if(_hasThePower) {				_nearestSwitch.activate();			}		}				public function activateMagneticPowers():void		{ 			_magnetizing = true;		}				public function applyMagneticPowers():void		{						//first we find the distance between two bodies			var distanceBetweenTwoBodies:b2Vec2 = _partner.GetPosition().Copy();			distanceBetweenTwoBodies.Subtract(_body.GetPosition());						//then create the unit vectors -- the direction			var directionToApplyForce:b2Vec2 = distanceBetweenTwoBodies.Copy();			directionToApplyForce.Normalize();						//create thresholds so that, when the distance between the two players are lower, we apply a constant force			var r_threshold:Number = PhysiVals.meters(80);			var threshold_magnitude:Number = 10;						var r:Number = distanceBetweenTwoBodies.Length();						//declare the force; we'll use it in the conditional			var force:b2Vec2;						if(r <= r_threshold) {				force = directionToApplyForce.Copy();				force.Multiply(threshold_magnitude);								_body.ApplyForce(force, _body.GetPosition());			} else {				//now we determine the magnitude of the force, according to Newton's Law of Universal Gravitation				var m1:Number = body.GetMass();				var m2:Number = _partner.body.GetMass();				var G:Number = 6.6 * Math.pow(10,2/3); //increase this to strengthen the attractive force				var magnitude:Number = G * m1 * m2 / (r/5); //r^2 is too weak, r is too strong								force = directionToApplyForce.Copy();				force.Multiply(magnitude);								_body.ApplyForce(force, _body.GetPosition());			}								}				public function deactivateMagneticPowers():void		{			_magnetizing = false;		}				private function applyExtraGravity():void		{			_body.ApplyForce(new b2Vec2(0, EXTRA_GRAVITY * _body.GetMass()), _body.GetWorldCenter());		}				override public function handleContact(otherObj):void		{			if(otherObj is Pool)			{				_inWater = true;			}					}						public function handleLethalContact(hazard):void		{			die();		}				override protected function cleanUpBeforeRemoving():void		{			//_partner = null;			//_footStep.clear();			//_footStep = null;		}				override public function destroy():void		{			//remove the costume sprite from display			_costume.parent.removeChild(_costume);						//remove actor from the world			PhysiVals.world.DestroyBody(_body);		}				public function landOn(otherObj):void		{						if(_body.GetLinearVelocity().y > 0) //we implement this check to make sure that we are pointed downwards			{				land();				playSFX("impact_wood.mp3");				handleContact(otherObj);			}						if (otherObj is Spring)			{				vaultFromSpring();			}			else if(otherObj is VirtualSpring) 			{				vault(otherObj.body.GetLinearVelocity().x * 2);				//trace(body.GetLinearVelocity().y);				if(body.GetLinearVelocity().y < -50) playSFX("neck_snap.mp3");			}		}						//COLLISION-RELATED functions 				//LANDING		public function land():void		{			_inAir = false;			_SFX.disableMovementTrail();						//sound fx			//var clank:Track = new Track("sfx/stomp_impact.mp3");		 	//clank.loop = false;			//clank.start();		}				override protected function updateOtherThings():void		{			if(!_inWater) {				applyExtraGravity();			}									if (PhysiVals.pixels(body.GetPosition().y) > 4000) {				this.die();			}						if (_magnetizing) {				if(_partner.GetPosition()!=_partnerPreviousPosition) {					applyMagneticPowers();				}			}						if (_movingDir == 1) {								moveX(1);				if(!_inAir) {					_footStep.resume();					_footStep.loop = true;				} else {					_footStep.pause();				}							}						if (_movingDir == -1) { 								moveX(-1);				if(!_inAir) {					_footStep.resume();					_footStep.loop = true;				} else {					_footStep.pause();				}							}						if (_movingDir == 0 && !_beLeaping) { //second condition ensures that the player being catapulted won't "stop."								_footStep.pause();								if(!_ridingMovingObject) {					moveX(0);									} else {					moveX(INHERIT_VX/BASE_VX);									}							}			}	}}